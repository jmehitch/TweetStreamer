#! python3
# PlotTweetData - uses data collected from TweetStreamer and converts SQLite database to CSV file, reads data and
# generates graphs of frequency of tweets over time and sentiment of tweets over time.

import csv
import sqlite3
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import datetime


def sql_to_csv(sql_file, csv_file):
    """
    Converts SQLite database to CSV file.

    Args:
        sql_file: filename of SQL database to access
        csv_file: filename of CSV file to write to

    Returns:
        Exported CSV file.
    """

    # Connect and retrieve data from SQLite DB
    db = sqlite3.connect(sql_file)
    cursor = db.cursor()
    data_to_transfer = cursor.execute("SELECT * FROM tweets")

    # Create CSV file and add headings
    with open(csv_file, "w") as file:
        writer = csv.writer(file)
        writer.writerow(["tweet_id", "tweet_text", "created_at", "location", "geo_coordinates",
                         "no_of_followers", "no_of_friends", "sentiment"])
        writer.writerows(data_to_transfer)
        file.close()
    return file


# Initialise dictionaries used to plot graphs in following functions.
tweetDict = {}
sentimentDict = {}


def read_csv_tweets(csv_file):
    """
    Reads CSV file, generates and stores data to plot for tweets over time graph in a dictionary.

    Args:
        csv_file: CSV file generated by sql_to_csv

    Returns:
        Dictionary of tweets and times to plot.
    """

    # Open CSV file
    file = open(csv_file, 'r')
    csv_open = csv.reader(file)

    # Read data from CSV file and add to tweet dictionary
    for line in csv_open:
        if line[0] == 'tweet_id':
            continue
        else:
            time = line[2]
            time_obj = datetime.datetime.strptime(time, '%Y-%m-%d %H:%M:%S')
            time_plot = mdates.date2num(time_obj)
            if time_plot in tweetDict.keys():
                tweetDict[time_plot] += 1
            else:
                tweetDict[time_plot] = 1
    return tweetDict


def read_csv_sentiment(csv_file):
    """
    Reads CSV file, generates and stores data to plot for sentiment over time graph in a dictionary.

    Args:
        csv_file: CSV file generated by sql_to_csv

    Returns:
        Dictionary of tweet sentiment data and time for plotting.
    """

    # Open CSV file
    file = open(csv_file, 'r')
    csv_open = csv.reader(file)

    # Read data from CSV file and add to sentiment dictionary
    for line in csv_open:
        if line[0] == 'tweet_id':
            continue
        else:
            time = line[2]
            time_obj = datetime.datetime.strptime(time, '%Y-%m-%d %H:%M:%S')
            time_plot = mdates.date2num(time_obj)
            sent = float(line[7])
            if time == '':
                continue
            else:
                sentimentDict[time_plot] = sent
    return sentimentDict


def generate_graphs(dict1, dict2):
    """
    Generates graphs with data stored in two dictionaries from CSV files.

    Args:
        dict1: dictionary to be used to plot first graph
        dict2: dictionary to be used to plot second graph

    Returns:
        Exported graphs.

    """

    # Define X and Y data points for first graph
    x1 = [k for k in dict1]
    y1 = [k for k in dict1.values()]

    # Defining X and Y data points for second graph
    x2 = [k for k in dict2]
    y2 = [k for k in dict2.values()]

    # Generate graphs
    plt.figure(1, figsize=(15, 5))

    # Create line graph for frequency of tweets over time
    plt.subplot(121)
    plt.plot_date(x1, y1, '-')
    plt.xlabel("Time (DD HH:MM)")
    plt.ylabel("Tweet Frequency")
    plt.title("Frequency of Tweets Over Time")

    # Create scatter graph for sentiment of tweets over time
    plt.subplot(122)
    plt.plot_date(x2, y2)
    plt.xlabel("Time (DD HH:MM)")
    plt.ylabel("Tweet Sentiment (+ve=1.00, -ve=-1.00)")
    plt.title("Sentiment of Tweets Over Time")
    plt.savefig("tweet_graphs.pdf")
    return plt


def main():
    """Main code block to run functions."""

    sql_to_csv(sql_filename, csv_filename)
    read_csv_tweets(csv_filename)
    read_csv_sentiment(csv_filename)
    generate_graphs(tweetDict, sentimentDict)


if __name__ == "__main__":
    sql_filename = "collected_tweets.db"
    csv_filename = "collected_tweets.csv"
    main()
